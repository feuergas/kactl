/*	就是利用(ax+b)(cx+d)可在三次乘法内解决	复杂度 n^(log3/log(2)),在cf上也只能过两万 暴力都能过啊！！	常数大,目测没什么用*/#include<iostream>#include<cstdio>using namespace std;int n,m,p,x,i,a[5000000],b[5000000],s[5000000];void doit(int q,int h,int x){	int i;	if (x==1)	s[q*2-1]=a[q]*b[q],s[q*2]=0;	else	{		int t=x/2;		for (i=q*2-1;i<=h*2;i++)	s[i]=0;		for (i=1;i<=t;i++) 	a[h+i]=a[q+i-1]+a[q+i+t-1];		for (i=1;i<=t;i++)	b[h+i]=b[q+i-1]+b[q+i+t-1];		doit(h+1,h+t,t);		for (i=t+1;i<=x+t;i++)	s[q*2-2+i]=s[2*h+i-t];		for (i=1;i<=t;i++) 	a[h+i]=a[q+i+t-1];		for (i=1;i<=t;i++)	b[h+i]=b[q+i+t-1];		doit(h+1,h+t,t);		for (i=x+1;i<=2*x;i++)	s[q*2-2+i]+=s[2*h+i-x];		for (i=t+1;i<=x+t;i++)	s[q*2-2+i]-=s[2*h+i-t];		for (i=1;i<=t;i++) 	a[h+i]=a[q+i-1];		for (i=1;i<=t;i++)	b[h+i]=b[q+i-1];		doit(h+1,h+t,t);		for (i=1;i<=x;i++)	s[q*2-2+i]+=s[2*h+i];		for (i=t+1;i<=x+t;i++)	s[q*2-2+i]-=s[2*h+i-t];	}}void read(int &a){	char k;	for (k=getchar();k<=32;k=getchar());	a=k-'0';}int main(){	scanf("%d",&n);	m = n;	for (i=1;i<=n;i++)	read(a[n-i+1]);	for (i=1;i<=m;i++)	read(b[n-i+1]);	x=max(n,m);	for (p=1;p<x;p*=2);	doit(1,p,p);	for (i=1;i<=2*p;i++)	{		s[i+1]+=s[i]/10;		s[i]%=10;	}	for (i=2*p;i&&!s[i];i--);	if (!i)	printf("%d",0);	else	for (;i;i--)	printf("%d",s[i]);}